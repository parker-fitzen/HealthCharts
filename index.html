<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Health Metrics Grapher</title>
  <style>
    :root{
      --bg:#f7f2fb;
      --panel:#ffffff;
      --panel2:#f3edf9;
      --text:#1f2937;
      --muted:#6b7280;
      --border:rgba(15, 23, 42, 0.12);
      --shadow: 0 10px 22px rgba(15, 23, 42, 0.10);
      --good:#d7f5d0;
      --caution:#fff3c4;
      --warn:#ffe3c8;
      --risk:#ffd2d6;
      --very:#e6dbf7;
      --blue:#d7edff;
      --good-text:#2f855a;
      --caution-text:#b7791f;
      --warn-text:#b45309;
      --risk-text:#b91c1c;
      --very-text:#6b46c1;
      --blue-text:#2563eb;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 15% 10%, rgba(196,181,253,.35), transparent 60%),
                  radial-gradient(1000px 700px at 80% 20%, rgba(251,207,232,.35), transparent 55%),
                  var(--bg);
      color:var(--text);
    }

    header{
      padding: 18px 18px 8px;
      max-width: 1100px;
      margin: 0 auto;
    }

    h1{
      margin:0 0 8px 0;
      font-size: 22px;
      letter-spacing: .2px;
    }

    .sub{
      margin:0;
      color:var(--muted);
      font-size: 14px;
      line-height: 1.35;
    }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:stretch;
      max-width:1100px;
      margin: 10px auto 16px;
      padding: 0 18px;
    }

    .card{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 12px 14px;
      flex: 1 1 420px;
      min-width: 320px;
    }

    .card h2{
      margin: 0 0 10px;
      font-size: 14px;
      color: #475569;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: .08em;
    }

    .controls{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      align-items:center;
    }

    input[type=file]{
      padding: 10px;
      border-radius: 12px;
      border:1px dashed rgba(71, 85, 105, 0.35);
      background: rgba(15, 23, 42, 0.02);
      color: var(--text);
      width: 100%;
      max-width: 520px;
    }

    button{
      appearance:none;
      border:1px solid var(--border);
      background: #f8fafc;
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      font-weight: 700;
    }

    button:hover{ background: rgba(15, 23, 42, 0.08); }

    .hint{
      margin-top: 10px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.4;
    }

    .setupNote{
      margin-top: 12px;
      padding-top: 10px;
      border-top: 1px solid var(--border);
      color: var(--muted);
      font-size: 13px;
      line-height: 1.4;
      display: flex;
      gap: 6px;
      align-items: center;
      flex-wrap: wrap;
    }

    .linkButton{
      border: none;
      background: none;
      color: #4f46e5;
      font-weight: 800;
      padding: 0;
      cursor: pointer;
      text-decoration: underline;
    }

    .linkButton:hover{
      color: #4338ca;
    }

    .mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: rgba(15, 23, 42, 0.05);
      border: 1px solid rgba(15, 23, 42, 0.08);
      padding: 10px;
      border-radius: 12px;
      overflow:auto;
      white-space: pre;
      font-size: 12px;
      color:#334155;
    }

    .status{
      margin-top: 10px;
      font-size: 13px;
      color: var(--muted);
    }

    .status.error{ color: #fecaca; }

    .charts{
      max-width: 1100px;
      margin: 0 auto 38px;
      padding: 0 18px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    .chartCard{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 10px;
    }

    .chartTitle{
      padding: 10px 10px 0;
      font-weight: 900;
      color: #1f2937;
      letter-spacing: .2px;
    }

    .sectionTitle{
      margin: 18px 0 2px;
      padding: 0 10px;
      font-weight: 900;
      font-size: 16px;
      color: #1f2937;
    }

    .sectionBlock + .sectionBlock{
      margin-top: 16px;
      border-top: 1px solid var(--border);
      padding-top: 8px;
    }

    .note{
      padding: 0 10px 10px;
      color: var(--muted);
      font-size: 12px;
    }

    .chartTooltip{
      position: fixed;
      background: rgba(255, 255, 255, 0.98);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      box-shadow: var(--shadow);
      font-size: 12px;
      color: var(--text);
      min-width: 180px;
      opacity: 0;
      pointer-events: none;
      transform: translateY(-4px);
      transition: opacity 120ms ease, transform 120ms ease;
      z-index: 20;
    }

    .chartTooltip.show{
      opacity: 1;
      transform: translateY(0);
    }

    .chartTooltip .label{
      color: var(--muted);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: .08em;
      font-weight: 700;
      margin-bottom: 2px;
    }

    .footerNote{
      max-width:1100px;
      margin: 0 auto;
      padding: 0 18px 26px;
      color: var(--muted);
      font-size: 12px;
      line-height:1.4;
    }

    .modalOverlay{
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.25);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 50;
      padding: 20px;
    }

    .modalOverlay.show{
      display: flex;
    }

    .modal{
      width: min(360px, 92vw);
      min-height: 520px;
      max-height: 82vh;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 22px;
      box-shadow: var(--shadow);
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .modalHeader{
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    .modalTitle{
      font-size: 16px;
      font-weight: 800;
      color: #1f2937;
    }

    .modalBody{
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px;
      background: var(--panel2);
      min-height: 240px;
      color: var(--text);
      overflow-y: auto;
    }

    .modalFooter{
      display: flex;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .modalFooter .controls{
      margin-left: auto;
    }

    .ghostButton{
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: transparent;
      color: var(--muted);
    }

    .modalDots{
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .dot{
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.5);
    }

    .dot.active{
      background: #6366f1;
    }

    .metricsGrid{
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
      margin-top: 8px;
    }

    .metricOption{
      display: flex;
      align-items: flex-start;
      gap: 8px;
      font-size: 13px;
      color: var(--text);
    }

    .templateBox{
      position: relative;
    }

    .copyButton{
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 10px;
    }

    @media (max-width: 680px){
      header{
        padding: 16px 14px 6px;
      }

      h1{
        font-size: 20px;
      }

      .row,
      .charts,
      .footerNote{
        padding: 0 14px;
      }

      .card{
        min-width: 0;
        flex: 1 1 100%;
      }

      input[type=file]{
        max-width: 100%;
      }
    }

    /* SVG text rendering */
    svg text{ font-family: inherit; }
  </style>
</head>
<body>
  <header>
    <h1>Health Metrics Grapher</h1>
    <p class="sub">Upload your template CSV and it will generate trend charts with reference bands (LDL, HDL, Total Cholesterol, Triglycerides, HbA1c).</p>
  </header>

  <div class="row">
    <div class="card">
      <h2>Upload CSV</h2>
      <div class="controls">
        <input id="file" type="file" accept=".csv,text/csv" />
        <button id="btnSample" type="button">Load sample</button>
      </div>
      <div id="status" class="status">No file loaded.</div>
      <div id="preview" class="mono">(upload a CSV)</div>
      <div class="setupNote">
        <span>Don't have a Health Charts CSV?</span>
        <button id="openSetup" class="linkButton" type="button">Get one set up here!</button>
      </div>
    </div>
  </div>

  <div id="charts" class="charts"></div>

  <div class="footerNote">
    Bands are common adult reference categories. Targets can differ by personal risk factors/conditions; use this for visualization, not diagnosis.
  </div>

  <div id="setupModal" class="modalOverlay" role="dialog" aria-modal="true" aria-labelledby="setupTitle">
    <div class="modal">
      <div class="modalHeader">
        <div>
          <div id="setupTitle" class="modalTitle">Health Charts CSV Setup</div>
          <div class="sub">Everything stays on your device.</div>
        </div>
        <button id="closeSetup" class="ghostButton" type="button">Close</button>
      </div>
      <div class="modalBody" id="setupBody"></div>
      <div class="modalFooter">
        <button id="backSetup" class="ghostButton" type="button">Back</button>
        <div class="modalDots" id="setupDots" aria-hidden="true"></div>
        <div class="controls">
          <button id="nextSetup" type="button">Next</button>
        </div>
      </div>
    </div>
  </div>

<script>
  // -------------------------
  // Config
  // -------------------------
  const COLORS = {
    good: getCss('--good'),
    caution: getCss('--caution'),
    warn: getCss('--warn'),
    risk: getCss('--risk'),
    very: getCss('--very'),
    blue: getCss('--blue'),
  };

  const TEXT_COLORS = {
    good: getCss('--good-text'),
    caution: getCss('--caution-text'),
    warn: getCss('--warn-text'),
    risk: getCss('--risk-text'),
    very: getCss('--very-text'),
    blue: getCss('--blue-text'),
  };

  const METRICS = [
    {
      key: 'LDL',
      title: 'LDL Cholesterol (lower is better)',
      unit: 'mg/dL',
      ranges: [
        { start: 0,   end: 100,  color: COLORS.good,    label: 'Optimal (<100)' },
        { start: 100, end: 130,  color: COLORS.caution, label: 'Near optimal (100–129)' },
        { start: 130, end: 160,  color: COLORS.warn,    label: 'Borderline high (130–159)' },
        { start: 160, end: 190,  color: COLORS.risk,    label: 'High (160–189)' },
        { start: 190, end: Infinity, color: COLORS.very, label: 'Very high (≥190)' },
      ]
    },
    {
      key: 'HDL',
      title: 'HDL Cholesterol (higher is better)',
      unit: 'mg/dL',
      ranges: [
        { start: 0,  end: 40,  color: COLORS.risk, label: 'Low (≤39)' },
        { start: 40, end: 60,  color: COLORS.good, label: 'Normal (40–59)' },
        { start: 60, end: Infinity, color: COLORS.blue, label: 'High (≥60)' },
      ]
    },
    {
      key: 'Total Cholesterol',
      title: 'Total Cholesterol',
      unit: 'mg/dL',
      ranges: [
        { start: 0,   end: 200, color: COLORS.good,    label: 'Desirable (<200)' },
        { start: 200, end: 240, color: COLORS.caution, label: 'Borderline (200–239)' },
        { start: 240, end: Infinity, color: COLORS.risk, label: 'High (≥240)' },
      ]
    },
    {
      key: 'Triglycerides',
      title: 'Triglycerides',
      unit: 'mg/dL',
      ranges: [
        { start: 0,   end: 150, color: COLORS.good,    label: 'Normal (<150)' },
        { start: 150, end: 200, color: COLORS.caution, label: 'Borderline (150–199)' },
        { start: 200, end: 500, color: COLORS.risk,    label: 'High (200–499)' },
        { start: 500, end: Infinity, color: COLORS.very, label: 'Very high (≥500)' },
      ]
    },
    {
      key: 'HBA1C',
      title: 'HbA1c (blood sugar)',
      unit: '%',
      ranges: [
        { start: 0,   end: 5.7, color: COLORS.good,    label: 'Normal (<5.7)' },
        { start: 5.7, end: 6.5, color: COLORS.caution, label: 'Prediabetes (5.7–6.4)' },
        { start: 6.5, end: Infinity, color: COLORS.risk, label: 'Diabetes (≥6.5)' },
      ]
    },
  ];

  const SECTIONS = [
    { title: 'Cholesterol Trends', keys: ['LDL','HDL','Total Cholesterol'] },
    { title: 'Metabolic Health Trends', keys: ['Triglycerides','HBA1C'] },
  ];

  // -------------------------
  // UI
  // -------------------------
  const elFile = document.getElementById('file');
  const elStatus = document.getElementById('status');
  const elPreview = document.getElementById('preview');
  const elCharts = document.getElementById('charts');
  const btnSample = document.getElementById('btnSample');
  const btnClear = document.getElementById('btnClear');
  const tooltip = createTooltip();
  const setupModal = document.getElementById('setupModal');
  const setupBody = document.getElementById('setupBody');
  const setupDots = document.getElementById('setupDots');
  const btnOpenSetup = document.getElementById('openSetup');
  const btnCloseSetup = document.getElementById('closeSetup');
  const btnNextSetup = document.getElementById('nextSetup');
  const btnBackSetup = document.getElementById('backSetup');
  let setupStep = 0;
  const selectedMetrics = new Set(METRICS.map((m) => m.key));

  elFile.addEventListener('change', async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    const text = await f.text();
    handleCsvText(text, f.name);
  });

  btnSample.addEventListener('click', () => {
    const sample = [
      'Date,LDL,HDL,Total Cholesterol,Triglycerides,HBA1C',
      '2/4/2025,118,57,206,157,5.0%',
      '10/7/2025,113,45,192,168,5.1%',
      '1/6/2026,84,42,156,148,',
    ].join('\n');
    handleCsvText(sample, 'sample.csv');
  });

  btnOpenSetup.addEventListener('click', () => {
    setupStep = 0;
    updateSetupStep();
    setupModal.classList.add('show');
  });

  btnCloseSetup.addEventListener('click', () => {
    setupModal.classList.remove('show');
  });

  setupModal.addEventListener('click', (event) => {
    if (event.target === setupModal){
      setupModal.classList.remove('show');
    }
  });

  btnNextSetup.addEventListener('click', () => {
    if (setupStep >= setupSteps.length - 1){
      setupModal.classList.remove('show');
      return;
    }
    setupStep = Math.min(setupStep + 1, setupSteps.length - 1);
    updateSetupStep();
  });

  btnBackSetup.addEventListener('click', () => {
    setupStep = Math.max(setupStep - 1, 0);
    updateSetupStep();
  });

  if (btnClear){
    btnClear.addEventListener('click', () => {
      elFile.value = '';
      elPreview.textContent = '(upload a CSV)';
      elCharts.innerHTML = '';
      setStatus('No file loaded.', false);
    });
  }

  function setStatus(msg, isError){
    elStatus.textContent = msg;
    elStatus.className = 'status' + (isError ? ' error' : '');
  }

  const setupSteps = [
    () => `
      <strong>Welcome to Health Charts.</strong>
      <p class="sub">All processing happens locally on your device after the site loads. Your CSV data never leaves your browser, is never transmitted to a server, and is only used to render charts locally.</p>
      <p class="sub">The only external signal is that someone visited the website. No health data is ever uploaded or shared.</p>
    `,
    () => `
      <strong>How it works</strong>
      <ol class="sub" style="padding-left:18px; margin:8px 0;">
        <li>Choose which metrics you want to track (you can leave any metric blank for a given test).</li>
        <li>Copy your custom template and paste it into a spreadsheet (Excel, Google Sheets, LibreOffice, etc.).</li>
        <li>Fill in your results and save the file as a .csv, then select it here to view your charts.</li>
      </ol>
    `,
    () => `
      <strong>Choose which metrics to include:</strong>
      <div class="metricsGrid">
        ${METRICS.map((metric) => `
          <label class="metricOption">
            <input type="checkbox" data-metric="${metric.key}" ${selectedMetrics.has(metric.key) ? 'checked' : ''} />
            <span>${metric.title}</span>
          </label>
        `).join('')}
      </div>
    `,
    () => `
      <strong>Your Template is Ready!</strong>
      <div class="templateBox" style="margin-top:10px;">
        <button id="copyTemplate" class="copyButton" type="button">Copy</button>
        <pre id="templateText" class="mono">${escapeHtml(buildTemplateText())}</pre>
      </div>
      <p class="sub" style="margin-top:10px;">Copy the text above, paste it into your spreadsheet, then save the file as a .csv (comma-separated values) file.</p>
    `,
    () => `
      <strong>Tutorial coming soon.</strong>
      <p class="sub">We’ll add a guided walkthrough once the setup flow is finalized.</p>
    `,
  ];

  setupBody.addEventListener('change', (event) => {
    if (!(event.target instanceof HTMLInputElement)) return;
    if (!event.target.matches('[data-metric]')) return;
    const key = event.target.dataset.metric;
    if (!key) return;
    if (event.target.checked){
      selectedMetrics.add(key);
    } else {
      selectedMetrics.delete(key);
    }
    updateSetupStep();
  });

  setupBody.addEventListener('click', (event) => {
    const target = event.target;
    if (!(target instanceof HTMLElement)) return;
    if (target.id !== 'copyTemplate') return;
    const text = buildTemplateText();
    if (navigator.clipboard?.writeText){
      navigator.clipboard.writeText(text).catch(() => {});
    }
  });

  function buildTemplateText(){
    const chosen = METRICS.filter((metric) => selectedMetrics.has(metric.key)).map((metric) => metric.key);
    const headers = ['Date', ...chosen];
    const sampleRow = headers.map((header, idx) => {
      if (idx === 0) return '1/15/2026';
      return '';
    });
    return `${headers.join(',')}\n${sampleRow.join(',')}`.trim();
  }

  function updateSetupStep(){
    setupDots.innerHTML = setupSteps.map((_, idx) => `
      <span class="dot ${idx === setupStep ? 'active' : ''}"></span>
    `).join('');
    btnBackSetup.disabled = setupStep === 0;
    btnNextSetup.textContent = setupStep === setupSteps.length - 1 ? 'Done' : 'Next';
    setupBody.innerHTML = setupSteps[setupStep]();
  }

  // -------------------------
  // CSV parsing + normalization
  // -------------------------
  function handleCsvText(text, filename){
    // Show preview (first ~30 lines)
    const lines = text.replace(/^\uFEFF/, '').split(/\r?\n/);
    elPreview.textContent = lines.slice(0, 30).join('\n');

    let rows;
    try{
      rows = parseCsv(text);
    }catch(err){
      console.error(err);
      setStatus('Could not parse CSV. Check for mismatched quotes/commas.', true);
      elCharts.innerHTML = '';
      return;
    }

    if (!rows.length){
      setStatus('CSV was empty.', true);
      elCharts.innerHTML = '';
      return;
    }

    // Normalize headers
    const header = rows[0].map(h => (h ?? '').trim().replace(/^\uFEFF/, ''));
    const idx = new Map(header.map((h,i)=>[h,i]));

    const required = ['Date', ...METRICS.map(m => m.key)];
    const missing = required.filter(h => !idx.has(h));
    if (missing.length){
      setStatus(`Missing required columns: ${missing.join(', ')}`, true);
      elCharts.innerHTML = '';
      return;
    }

    const parsed = [];
    for (let r = 1; r < rows.length; r++){
      const row = rows[r];
      const dateStr = (row[idx.get('Date')] ?? '').trim();
      if (!dateStr) continue; // skip blank rows

      const date = parseMDY(dateStr);
      if (!date){
        // Skip invalid date rows
        continue;
      }

      const obj = { Date: date, _rawDate: dateStr };
      for (const m of METRICS){
        const raw = (row[idx.get(m.key)] ?? '').trim();
        obj[m.key] = parseNumberMaybePercent(raw);
      }
      parsed.push(obj);
    }

    if (parsed.length < 1){
      setStatus('No valid data rows found (check Date format).', true);
      elCharts.innerHTML = '';
      return;
    }

    // Sort by date
    parsed.sort((a,b)=>a.Date - b.Date);

    setStatus(`Loaded ${filename} — ${parsed.length} row(s).`, false);
    renderAll(parsed);
  }

  function parseNumberMaybePercent(s){
    if (!s) return null;
    const cleaned = s.replace('%','').replace(/,/g,'').trim();
    if (!cleaned) return null;
    const n = Number(cleaned);
    return Number.isFinite(n) ? n : null;
  }

  function parseMDY(s){
    // Accept M/D/YYYY or MM/DD/YYYY
    const m = s.trim().match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
    if (!m) return null;
    const mm = Number(m[1]);
    const dd = Number(m[2]);
    const yy = Number(m[3]);
    const d = new Date(yy, mm - 1, dd);
    // Validate
    if (d.getFullYear() !== yy || d.getMonth() !== mm - 1 || d.getDate() !== dd) return null;
    return d;
  }

  function parseCsv(text){
    // Minimal CSV parser that handles quotes.
    const s = text.replace(/^\uFEFF/, '');
    const rows = [];
    let row = [];
    let cur = '';
    let inQuotes = false;

    for (let i=0; i<s.length; i++){
      const ch = s[i];

      if (inQuotes){
        if (ch === '"'){
          const next = s[i+1];
          if (next === '"'){
            cur += '"';
            i++;
          } else {
            inQuotes = false;
          }
        } else {
          cur += ch;
        }
        continue;
      }

      if (ch === '"'){
        inQuotes = true;
        continue;
      }

      if (ch === ','){
        row.push(cur);
        cur = '';
        continue;
      }

      if (ch === '\n'){
        row.push(cur);
        rows.push(row);
        row = [];
        cur = '';
        continue;
      }

      if (ch === '\r'){
        continue;
      }

      cur += ch;
    }

    // flush last field
    row.push(cur);
    // Only push if there is at least one non-empty cell
    if (row.some(v => (v ?? '').trim() !== '')) rows.push(row);

    return rows;
  }

  // -------------------------
  // Chart rendering (SVG)
  // -------------------------
  function renderAll(dataRows){
    elCharts.innerHTML = '';
    const container = document.createElement('div');
    container.className = 'chartCard';

    for (const sec of SECTIONS){
      const section = document.createElement('div');
      section.className = 'sectionBlock';
      section.innerHTML = `
        <div class="sectionTitle">${escapeHtml(sec.title)} ( ${formatSpan(dataRows)} )</div>
        <div class="note">Colored bands are reference categories. The line is your trend. Values are labeled at each measurement.</div>
      `;

      for (const key of sec.keys){
        const metric = METRICS.find(m => m.key === key);
        const svg = makeChartSvg(dataRows, metric);
        section.appendChild(svg);
      }

      container.appendChild(section);
    }

    elCharts.appendChild(container);
  }

  function formatSpan(rows){
    const min = rows[0].Date;
    const max = rows[rows.length-1].Date;
    const fmt = new Intl.DateTimeFormat(undefined, { month:'short', year:'numeric' });
    return `${fmt.format(min)} – ${fmt.format(max)}`;
  }

  function recommendedYTop(maxVal, ranges){
    // Tighten y-axis: show context up to the band ceiling you're actually in,
    // rather than zooming out to the highest extreme cutoff.
    let bandEnd = null;
    for (const r of ranges){
      if (r.end === Infinity){
        if (maxVal >= r.start){ bandEnd = null; break; }
      } else {
        if (maxVal >= r.start && maxVal <= r.end){ bandEnd = r.end; break; }
      }
    }

    const fromData = (maxVal > 0 ? maxVal * 1.25 : 1);
    if (bandEnd != null){
      return Math.max(fromData, bandEnd * 1.05);
    }
    return fromData * 1.10;
  }

  function makeChartSvg(rows, metric){
    const W = 980;
    const H = 260;

    const margin = { top: 34, right: 170, bottom: 44, left: 64 };
    const plotW = W - margin.left - margin.right;
    const plotH = H - margin.top - margin.bottom;

    const values = rows.map(r => r[metric.key]).filter(v => v != null);
    const hasData = values.length > 0;

    const minT = rows[0].Date.getTime();
    const maxT = rows[rows.length-1].Date.getTime();
    const spanT = Math.max(1, maxT - minT);
    const padT = spanT * 0.10;

    const xMin = minT - padT;
    const xMax = maxT + padT;

    const maxV = hasData ? Math.max(...values) : 1;
    const yTop = recommendedYTop(maxV, metric.ranges);
    const yMin = 0;

    const x = (date) => margin.left + ((date.getTime() - xMin) / (xMax - xMin)) * plotW;
    const y = (val)  => margin.top + (1 - ((val - yMin) / (yTop - yMin))) * plotH;

    const svg = elNS('svg');
    svg.setAttribute('width', '100%');
    svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
    svg.style.display = 'block';
    svg.style.margin = '10px 0 14px';

    // Background
    svg.appendChild(rect(0,0,W,H,'rgba(15, 23, 42, 0.03)'));

    // Title
    svg.appendChild(textEl(metric.title, margin.left, 18, {
      size: 15,
      weight: 900,
      fill: '#1f2937'
    }));

    // Y-axis label
    svg.appendChild(textEl(metric.unit, 14, margin.top + plotH/2, {
      size: 12,
      weight: 800,
      fill: '#64748b',
      rotate: -90,
      rotateOrigin: `14 ${margin.top + plotH/2}`
    }));

    // Bands (contiguous; avoids white stripes)
    for (const r of metric.ranges){
      const start = r.start;
      const end = (r.end === Infinity ? yTop : Math.min(r.end, yTop));
      if (start >= yTop) continue;

      const y1 = y(end);
      const y2 = y(start);
      svg.appendChild(rect(margin.left, y1, plotW, (y2 - y1), r.color, 0.60));

      // Right-side label
      const yMid = y1 + (y2 - y1)/2;
      const lbl = textEl(r.label, margin.left + plotW + 10, yMid + 4, {
        size: 11,
        weight: 800,
        fill: '#d1d5db'
      });
      svg.appendChild(lbl);
    }

    // Grid + y ticks
    const gridCount = 5;
    for (let i=0; i<=gridCount; i++){
      const v = (yTop / gridCount) * i;
      const yy = y(v);
      svg.appendChild(line(margin.left, yy, margin.left + plotW, yy, 'rgba(15, 23, 42, 0.12)', 1, '4,4'));
      svg.appendChild(textEl(formatTick(v, metric.key), margin.left - 8, yy + 4, {
        size: 11,
        weight: 700,
        fill: '#64748b',
        anchor: 'end'
      }));
    }

    // X axis baseline
    svg.appendChild(line(margin.left, margin.top + plotH, margin.left + plotW, margin.top + plotH, 'rgba(15, 23, 42, 0.25)', 1.2));

    // X ticks (auto)
    const ticks = makeTimeTicks(xMin, xMax, 5);
    for (const t of ticks){
      const xx = margin.left + ((t - xMin) / (xMax - xMin)) * plotW;
      svg.appendChild(line(xx, margin.top + plotH, xx, margin.top + plotH + 6, 'rgba(15, 23, 42, 0.25)', 1));
      svg.appendChild(textEl(formatDateTick(new Date(t), xMin, xMax), xx, margin.top + plotH + 22, {
        size: 11,
        weight: 700,
        fill: '#64748b',
        anchor: 'middle'
      }));
    }

    // Build series points
    const pts = rows
      .filter(r => r[metric.key] != null)
      .map(r => ({ d: r.Date, v: r[metric.key], rawDate: r._rawDate }));

    // Line
    if (pts.length >= 1){
      const path = pts.map((p, i) => `${i===0 ? 'M' : 'L'} ${x(p.d).toFixed(2)} ${y(p.v).toFixed(2)}`).join(' ');
      const pEl = elNS('path');
      pEl.setAttribute('d', path);
      pEl.setAttribute('fill', 'none');
      pEl.setAttribute('stroke', '#334155');
      pEl.setAttribute('stroke-width', '4');
      pEl.setAttribute('opacity', '0.55');
      svg.appendChild(pEl);

      const pEl2 = elNS('path');
      pEl2.setAttribute('d', path);
      pEl2.setAttribute('fill', 'none');
      pEl2.setAttribute('stroke', '#1f2937');
      pEl2.setAttribute('stroke-width', '2.5');
      svg.appendChild(pEl2);

      // Points + labels
      for (const p of pts){
        const cx = x(p.d);
        const cy = y(p.v);
        const point = circle(cx, cy, 4.5, '#1f2937');
        point.classList.add('dataPoint');
        point.dataset.value = String(p.v);
        point.dataset.date = p.rawDate || '';
        point.dataset.dateFormatted = formatFullDate(p.rawDate, p.d);
        point.dataset.metric = metric.key;
        svg.appendChild(point);
        attachTooltipHandlers(svg, point, metric);

        // value label with white pill background
        const label = formatValue(p.v, metric.key);
        const padX = 6;
        const padY = 4;
        const textSize = 12;

        // approximate text width (good enough)
        const approxW = Math.max(20, label.length * 7.1);
        const boxW = approxW + padX*2;
        const boxH = textSize + padY*2;

        const bx = cx - boxW/2;
        const by = cy - 22 - boxH/2;

        svg.appendChild(roundRect(bx, by, boxW, boxH, 6, 'rgba(255,255,255,0.95)'));
        svg.appendChild(textEl(label, cx, by + boxH/2 + 4, {
          size: 12,
          weight: 900,
          fill: '#1f2937',
          anchor: 'middle'
        }));
      }
    }

    return svg;
  }

  function makeTimeTicks(minT, maxT, count){
    const ticks = [];
    const span = maxT - minT;
    if (span <= 0) return [minT, maxT];

    // choose tick spacing roughly based on span
    const day = 86400000;
    const month = 30*day;
    const year = 365*day;

    let step;
    if (span <= 120*day) step = 30*day;           // ~monthly
    else if (span <= 540*day) step = 90*day;      // ~quarterly
    else if (span <= 2.5*year) step = 180*day;    // ~semiannual
    else step = 365*day;

    // start at nearest step boundary
    let t = minT;
    // just evenly distribute if very short
    const target = Math.min(6, Math.max(3, count));
    const approx = Math.floor(span / step) + 1;

    if (approx < target){
      // evenly spaced
      for (let i=0; i<target; i++){
        ticks.push(minT + (span * i)/(target-1));
      }
      return ticks;
    }

    // walk forward in steps
    while (t <= maxT + 1){
      ticks.push(t);
      t += step;
      if (ticks.length > 8) break;
    }

    // ensure last tick near end
    if (ticks[ticks.length-1] < maxT - step*0.35) ticks.push(maxT);

    // de-dup close ticks
    return ticks.filter((v,i,a)=> i===0 || Math.abs(v-a[i-1]) > step*0.35);
  }

  function formatDateTick(d, minT, maxT){
    const span = maxT - minT;
    const day = 86400000;
    const showYear = span > 320*day;
    const fmt = new Intl.DateTimeFormat(undefined, showYear
      ? { month:'short', year:'numeric' }
      : { month:'short', day:'numeric' }
    );
    return fmt.format(d);
  }

  function formatValue(v, key){
    if (key === 'HBA1C') return v.toFixed(1);
    // avoid trailing .0 for integers
    return Number.isInteger(v) ? String(v) : String(v);
  }

  function formatFullDate(dateString, dateObj){
    if (dateObj instanceof Date){
      return new Intl.DateTimeFormat(undefined, { month:'short', day:'numeric', year:'numeric' }).format(dateObj);
    }
    return dateString || '';
  }

  function formatTick(v, key){
    if (key === 'HBA1C') return v.toFixed(1);
    // show clean integers
    const rounded = Math.round(v);
    return String(rounded);
  }

  function findCategory(metric, value){
    for (const r of metric.ranges){
      if (value >= r.start && (value < r.end || r.end === Infinity)){
        return r;
      }
    }
    return metric.ranges[metric.ranges.length - 1];
  }

  function categoryTextColor(rangeColor){
    switch (rangeColor){
      case COLORS.good:
        return TEXT_COLORS.good;
      case COLORS.caution:
        return TEXT_COLORS.caution;
      case COLORS.warn:
        return TEXT_COLORS.warn;
      case COLORS.risk:
        return TEXT_COLORS.risk;
      case COLORS.very:
        return TEXT_COLORS.very;
      case COLORS.blue:
        return TEXT_COLORS.blue;
      default:
        return TEXT_COLORS.good;
    }
  }

  function attachTooltipHandlers(svg, point, metric){
    point.addEventListener('mouseenter', (event) => {
      showTooltip(event, svg, point, metric);
    });

    point.addEventListener('click', (event) => {
      event.stopPropagation();
      showTooltip(event, svg, point, metric);
    });

    point.addEventListener('mouseleave', () => {
      if (!tooltip.dataset.locked){
        hideTooltip();
      }
    });
  }

  function showTooltip(event, svg, point, metric){
    const value = Number(point.dataset.value);
    const category = findCategory(metric, value);
    const categoryColor = categoryTextColor(category.color);
    const dateLabel = point.dataset.dateFormatted || point.dataset.date || '';
    tooltip.innerHTML = `
      <div class="label">Test Date</div>
      <div>${escapeHtml(dateLabel)}</div>
      <div class="label" style="margin-top:8px;">Measurement</div>
      <div>${formatValue(value, metric.key)} ${metric.unit}</div>
      <div class="label" style="margin-top:8px;">Category</div>
      <div style="color:${categoryColor}; font-weight:800;">${escapeHtml(category.label)}</div>
    `;

    positionTooltip(svg, point);
    tooltip.classList.add('show');
    tooltip.dataset.locked = event.type === 'click' ? 'true' : '';
  }

  function positionTooltip(svg, point){
    const rect = svg.getBoundingClientRect();
    const viewBox = svg.viewBox.baseVal;
    const scaleX = rect.width / viewBox.width;
    const scaleY = rect.height / viewBox.height;
    const cx = Number(point.getAttribute('cx')) * scaleX + rect.left;
    const cy = Number(point.getAttribute('cy')) * scaleY + rect.top;
    const offset = 14;

    tooltip.style.left = `${Math.min(window.innerWidth - 220, Math.max(10, cx + offset))}px`;
    tooltip.style.top = `${Math.min(window.innerHeight - 120, Math.max(10, cy - 10))}px`;
  }

  function hideTooltip(){
    tooltip.classList.remove('show');
    tooltip.dataset.locked = '';
  }

  function createTooltip(){
    const tip = document.createElement('div');
    tip.className = 'chartTooltip';
    document.body.appendChild(tip);
    document.addEventListener('click', () => hideTooltip());
    window.addEventListener('scroll', () => hideTooltip());
    return tip;
  }

  // -------------------------
  // SVG helper functions
  // -------------------------
  function elNS(tag){
    return document.createElementNS('http://www.w3.org/2000/svg', tag);
  }

  function rect(x,y,w,h,fill,opacity){
    const r = elNS('rect');
    r.setAttribute('x', x);
    r.setAttribute('y', y);
    r.setAttribute('width', w);
    r.setAttribute('height', h);
    r.setAttribute('fill', fill);
    if (opacity != null) r.setAttribute('opacity', String(opacity));
    return r;
  }

  function roundRect(x,y,w,h,rad,fill,opacity){
    const r = rect(x,y,w,h,fill,opacity);
    r.setAttribute('rx', rad);
    r.setAttribute('ry', rad);
    return r;
  }

  function line(x1,y1,x2,y2,stroke,width,dash){
    const l = elNS('line');
    l.setAttribute('x1', x1);
    l.setAttribute('y1', y1);
    l.setAttribute('x2', x2);
    l.setAttribute('y2', y2);
    l.setAttribute('stroke', stroke);
    l.setAttribute('stroke-width', width);
    if (dash) l.setAttribute('stroke-dasharray', dash);
    return l;
  }

  function circle(cx,cy,r,fill){
    const c = elNS('circle');
    c.setAttribute('cx', cx);
    c.setAttribute('cy', cy);
    c.setAttribute('r', r);
    c.setAttribute('fill', fill);
    return c;
  }

  function textEl(str, x, y, opts={}){
    const t = elNS('text');
    t.textContent = str;
    t.setAttribute('x', x);
    t.setAttribute('y', y);
    t.setAttribute('fill', opts.fill ?? '#1f2937');
    t.setAttribute('font-size', opts.size ?? 12);
    t.setAttribute('font-weight', opts.weight ?? 700);
    if (opts.anchor) t.setAttribute('text-anchor', opts.anchor);
    if (opts.rotate != null){
      t.setAttribute('transform', `rotate(${opts.rotate} ${opts.rotateOrigin ?? (x+' '+y)})`);
    }
    return t;
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  function getCss(name){
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  }
</script>
</body>
</html>
