<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Health Metrics Grapher (CSV Upload)</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#111827;
      --panel2:#0f172a;
      --text:#e5e7eb;
      --muted:#94a3b8;
      --border:rgba(255,255,255,.10);
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --good:#d9f0a3;
      --caution:#fdedb3;
      --warn:#fdbf6f;
      --risk:#fb9a99;
      --very:#cab2d6;
      --blue:#a6cee3;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 15% 10%, rgba(56,189,248,.10), transparent 60%),
                  radial-gradient(1000px 700px at 80% 20%, rgba(167,139,250,.10), transparent 55%),
                  var(--bg);
      color:var(--text);
    }

    header{
      padding: 22px 18px 14px;
      max-width: 1100px;
      margin: 0 auto;
    }

    h1{
      margin:0 0 8px 0;
      font-size: 22px;
      letter-spacing: .2px;
    }

    .sub{
      margin:0;
      color:var(--muted);
      font-size: 14px;
      line-height: 1.35;
    }

    .row{
      display:flex;
      gap:14px;
      flex-wrap:wrap;
      align-items:stretch;
      max-width:1100px;
      margin: 12px auto 24px;
      padding: 0 18px;
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 14px;
      flex: 1 1 420px;
      min-width: 320px;
    }

    .card h2{
      margin: 0 0 10px;
      font-size: 14px;
      color: #cbd5e1;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: .08em;
    }

    .controls{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      align-items:center;
    }

    input[type=file]{
      padding: 10px;
      border-radius: 12px;
      border:1px dashed rgba(255,255,255,.25);
      background: rgba(255,255,255,.03);
      color: var(--text);
      width: 100%;
      max-width: 520px;
    }

    button{
      appearance:none;
      border:1px solid var(--border);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      font-weight: 700;
    }

    button:hover{ background: rgba(255,255,255,.10); }

    .hint{
      margin-top: 10px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.4;
    }

    .mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: rgba(0,0,0,.28);
      border: 1px solid rgba(255,255,255,.10);
      padding: 10px;
      border-radius: 12px;
      overflow:auto;
      white-space: pre;
      font-size: 12px;
      color:#d1d5db;
    }

    .status{
      margin-top: 10px;
      font-size: 13px;
      color: var(--muted);
    }

    .status.error{ color: #fecaca; }

    .charts{
      max-width: 1100px;
      margin: 0 auto 38px;
      padding: 0 18px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    .chartCard{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 10px;
    }

    .chartTitle{
      padding: 10px 10px 0;
      font-weight: 900;
      color: #e2e8f0;
      letter-spacing: .2px;
    }

    .sectionTitle{
      margin: 18px 0 2px;
      padding: 0 10px;
      font-weight: 900;
      font-size: 16px;
      color: #e2e8f0;
    }

    .sectionBlock + .sectionBlock{
      margin-top: 16px;
      border-top: 1px solid var(--border);
      padding-top: 8px;
    }

    .note{
      padding: 0 10px 10px;
      color: var(--muted);
      font-size: 12px;
    }

    .footerNote{
      max-width:1100px;
      margin: 0 auto;
      padding: 0 18px 26px;
      color: var(--muted);
      font-size: 12px;
      line-height:1.4;
    }

    /* SVG text rendering */
    svg text{ font-family: inherit; }
  </style>
</head>
<body>
  <header>
    <h1>Health Metrics Grapher</h1>
    <p class="sub">Upload a CSV and it will generate trend charts with reference bands (LDL, HDL, Total Cholesterol, Triglycerides, HbA1c).</p>
  </header>

  <div class="row">
    <div class="card">
      <h2>Upload CSV</h2>
      <div class="controls">
        <input id="file" type="file" accept=".csv,text/csv" />
        <button id="btnSample" type="button">Load sample</button>
        <button id="btnClear" type="button">Clear</button>
      </div>
      <div class="hint">
        Expected header (order doesn’t matter; names must match):
        <div class="mono" style="margin-top:8px;">Date,LDL,HDL,Total Cholesterol,Triglycerides,HBA1C</div>
        Notes:
        <ul style="margin:6px 0 0 18px; padding:0; color:var(--muted);">
          <li><b>Date</b> should be like <span class="mono">2/4/2025</span> (M/D/YYYY).</li>
          <li>Numbers can be plain (e.g., <span class="mono">118</span>) and HbA1c may optionally include a <span class="mono">%</span> sign (e.g., <span class="mono">5.1%</span>).</li>
          <li>Blank cells are treated as missing values.</li>
        </ul>
      </div>
      <div id="status" class="status">No file loaded.</div>
    </div>

    <div class="card">
      <h2>CSV preview</h2>
      <div id="preview" class="mono" style="min-height: 160px; max-height: 260px;">(upload a CSV)</div>
    </div>
  </div>

  <div id="charts" class="charts"></div>

  <div class="footerNote">
    Bands are common adult reference categories. Targets can differ by personal risk factors/conditions; use this for visualization, not diagnosis.
  </div>

<script>
  // -------------------------
  // Config
  // -------------------------
  const COLORS = {
    good: getCss('--good'),
    caution: getCss('--caution'),
    warn: getCss('--warn'),
    risk: getCss('--risk'),
    very: getCss('--very'),
    blue: getCss('--blue'),
  };

  const METRICS = [
    {
      key: 'LDL',
      title: 'LDL Cholesterol (lower is better)',
      unit: 'mg/dL',
      ranges: [
        { start: 0,   end: 100,  color: COLORS.good,    label: 'Optimal (<100)' },
        { start: 100, end: 130,  color: COLORS.caution, label: 'Near optimal (100–129)' },
        { start: 130, end: 160,  color: COLORS.warn,    label: 'Borderline high (130–159)' },
        { start: 160, end: 190,  color: COLORS.risk,    label: 'High (160–189)' },
        { start: 190, end: Infinity, color: COLORS.very, label: 'Very high (≥190)' },
      ]
    },
    {
      key: 'HDL',
      title: 'HDL Cholesterol (higher is better)',
      unit: 'mg/dL',
      ranges: [
        { start: 0,  end: 40,  color: COLORS.risk, label: 'Low (≤39)' },
        { start: 40, end: 60,  color: COLORS.good, label: 'Normal (40–59)' },
        { start: 60, end: Infinity, color: COLORS.blue, label: 'High (≥60)' },
      ]
    },
    {
      key: 'Total Cholesterol',
      title: 'Total Cholesterol',
      unit: 'mg/dL',
      ranges: [
        { start: 0,   end: 200, color: COLORS.good,    label: 'Desirable (<200)' },
        { start: 200, end: 240, color: COLORS.caution, label: 'Borderline (200–239)' },
        { start: 240, end: Infinity, color: COLORS.risk, label: 'High (≥240)' },
      ]
    },
    {
      key: 'Triglycerides',
      title: 'Triglycerides',
      unit: 'mg/dL',
      ranges: [
        { start: 0,   end: 150, color: COLORS.good,    label: 'Normal (<150)' },
        { start: 150, end: 200, color: COLORS.caution, label: 'Borderline (150–199)' },
        { start: 200, end: 500, color: COLORS.risk,    label: 'High (200–499)' },
        { start: 500, end: Infinity, color: COLORS.very, label: 'Very high (≥500)' },
      ]
    },
    {
      key: 'HBA1C',
      title: 'HbA1c (blood sugar)',
      unit: '%',
      ranges: [
        { start: 0,   end: 5.7, color: COLORS.good,    label: 'Normal (<5.7)' },
        { start: 5.7, end: 6.5, color: COLORS.caution, label: 'Prediabetes (5.7–6.4)' },
        { start: 6.5, end: Infinity, color: COLORS.risk, label: 'Diabetes (≥6.5)' },
      ]
    },
  ];

  const SECTIONS = [
    { title: 'Cholesterol Trends', keys: ['LDL','HDL','Total Cholesterol'] },
    { title: 'Metabolic Health Trends', keys: ['Triglycerides','HBA1C'] },
  ];

  // -------------------------
  // UI
  // -------------------------
  const elFile = document.getElementById('file');
  const elStatus = document.getElementById('status');
  const elPreview = document.getElementById('preview');
  const elCharts = document.getElementById('charts');
  const btnSample = document.getElementById('btnSample');
  const btnClear = document.getElementById('btnClear');

  elFile.addEventListener('change', async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    const text = await f.text();
    handleCsvText(text, f.name);
  });

  btnSample.addEventListener('click', () => {
    const sample = [
      'Date,LDL,HDL,Total Cholesterol,Triglycerides,HBA1C',
      '2/4/2025,118,57,206,157,5.0%',
      '10/7/2025,113,45,192,168,5.1%',
      '1/6/2026,84,42,156,148,',
    ].join('\n');
    handleCsvText(sample, 'sample.csv');
  });

  btnClear.addEventListener('click', () => {
    elFile.value = '';
    elPreview.textContent = '(upload a CSV)';
    elCharts.innerHTML = '';
    setStatus('No file loaded.', false);
  });

  function setStatus(msg, isError){
    elStatus.textContent = msg;
    elStatus.className = 'status' + (isError ? ' error' : '');
  }

  // -------------------------
  // CSV parsing + normalization
  // -------------------------
  function handleCsvText(text, filename){
    // Show preview (first ~30 lines)
    const lines = text.replace(/^\uFEFF/, '').split(/\r?\n/);
    elPreview.textContent = lines.slice(0, 30).join('\n');

    let rows;
    try{
      rows = parseCsv(text);
    }catch(err){
      console.error(err);
      setStatus('Could not parse CSV. Check for mismatched quotes/commas.', true);
      elCharts.innerHTML = '';
      return;
    }

    if (!rows.length){
      setStatus('CSV was empty.', true);
      elCharts.innerHTML = '';
      return;
    }

    // Normalize headers
    const header = rows[0].map(h => (h ?? '').trim().replace(/^\uFEFF/, ''));
    const idx = new Map(header.map((h,i)=>[h,i]));

    const required = ['Date', ...METRICS.map(m => m.key)];
    const missing = required.filter(h => !idx.has(h));
    if (missing.length){
      setStatus(`Missing required columns: ${missing.join(', ')}`, true);
      elCharts.innerHTML = '';
      return;
    }

    const parsed = [];
    for (let r = 1; r < rows.length; r++){
      const row = rows[r];
      const dateStr = (row[idx.get('Date')] ?? '').trim();
      if (!dateStr) continue; // skip blank rows

      const date = parseMDY(dateStr);
      if (!date){
        // Skip invalid date rows
        continue;
      }

      const obj = { Date: date, _rawDate: dateStr };
      for (const m of METRICS){
        const raw = (row[idx.get(m.key)] ?? '').trim();
        obj[m.key] = parseNumberMaybePercent(raw);
      }
      parsed.push(obj);
    }

    if (parsed.length < 1){
      setStatus('No valid data rows found (check Date format).', true);
      elCharts.innerHTML = '';
      return;
    }

    // Sort by date
    parsed.sort((a,b)=>a.Date - b.Date);

    setStatus(`Loaded ${filename} — ${parsed.length} row(s).`, false);
    renderAll(parsed);
  }

  function parseNumberMaybePercent(s){
    if (!s) return null;
    const cleaned = s.replace('%','').replace(/,/g,'').trim();
    if (!cleaned) return null;
    const n = Number(cleaned);
    return Number.isFinite(n) ? n : null;
  }

  function parseMDY(s){
    // Accept M/D/YYYY or MM/DD/YYYY
    const m = s.trim().match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
    if (!m) return null;
    const mm = Number(m[1]);
    const dd = Number(m[2]);
    const yy = Number(m[3]);
    const d = new Date(yy, mm - 1, dd);
    // Validate
    if (d.getFullYear() !== yy || d.getMonth() !== mm - 1 || d.getDate() !== dd) return null;
    return d;
  }

  function parseCsv(text){
    // Minimal CSV parser that handles quotes.
    const s = text.replace(/^\uFEFF/, '');
    const rows = [];
    let row = [];
    let cur = '';
    let inQuotes = false;

    for (let i=0; i<s.length; i++){
      const ch = s[i];

      if (inQuotes){
        if (ch === '"'){
          const next = s[i+1];
          if (next === '"'){
            cur += '"';
            i++;
          } else {
            inQuotes = false;
          }
        } else {
          cur += ch;
        }
        continue;
      }

      if (ch === '"'){
        inQuotes = true;
        continue;
      }

      if (ch === ','){
        row.push(cur);
        cur = '';
        continue;
      }

      if (ch === '\n'){
        row.push(cur);
        rows.push(row);
        row = [];
        cur = '';
        continue;
      }

      if (ch === '\r'){
        continue;
      }

      cur += ch;
    }

    // flush last field
    row.push(cur);
    // Only push if there is at least one non-empty cell
    if (row.some(v => (v ?? '').trim() !== '')) rows.push(row);

    return rows;
  }

  // -------------------------
  // Chart rendering (SVG)
  // -------------------------
  function renderAll(dataRows){
    elCharts.innerHTML = '';
    const container = document.createElement('div');
    container.className = 'chartCard';

    for (const sec of SECTIONS){
      const section = document.createElement('div');
      section.className = 'sectionBlock';
      section.innerHTML = `
        <div class="sectionTitle">${escapeHtml(sec.title)} ( ${formatSpan(dataRows)} )</div>
        <div class="note">Colored bands are reference categories. The line is your trend. Values are labeled at each measurement.</div>
      `;

      for (const key of sec.keys){
        const metric = METRICS.find(m => m.key === key);
        const svg = makeChartSvg(dataRows, metric);
        section.appendChild(svg);
      }

      container.appendChild(section);
    }

    elCharts.appendChild(container);
  }

  function formatSpan(rows){
    const min = rows[0].Date;
    const max = rows[rows.length-1].Date;
    const fmt = new Intl.DateTimeFormat(undefined, { month:'short', year:'numeric' });
    return `${fmt.format(min)} – ${fmt.format(max)}`;
  }

  function recommendedYTop(maxVal, ranges){
    // Tighten y-axis: show context up to the band ceiling you're actually in,
    // rather than zooming out to the highest extreme cutoff.
    let bandEnd = null;
    for (const r of ranges){
      if (r.end === Infinity){
        if (maxVal >= r.start){ bandEnd = null; break; }
      } else {
        if (maxVal >= r.start && maxVal <= r.end){ bandEnd = r.end; break; }
      }
    }

    const fromData = (maxVal > 0 ? maxVal * 1.25 : 1);
    if (bandEnd != null){
      return Math.max(fromData, bandEnd * 1.05);
    }
    return fromData * 1.10;
  }

  function makeChartSvg(rows, metric){
    const W = 980;
    const H = 260;

    const margin = { top: 34, right: 170, bottom: 44, left: 64 };
    const plotW = W - margin.left - margin.right;
    const plotH = H - margin.top - margin.bottom;

    const values = rows.map(r => r[metric.key]).filter(v => v != null);
    const hasData = values.length > 0;

    const minT = rows[0].Date.getTime();
    const maxT = rows[rows.length-1].Date.getTime();
    const spanT = Math.max(1, maxT - minT);
    const padT = spanT * 0.10;

    const xMin = minT - padT;
    const xMax = maxT + padT;

    const maxV = hasData ? Math.max(...values) : 1;
    const yTop = recommendedYTop(maxV, metric.ranges);
    const yMin = 0;

    const x = (date) => margin.left + ((date.getTime() - xMin) / (xMax - xMin)) * plotW;
    const y = (val)  => margin.top + (1 - ((val - yMin) / (yTop - yMin))) * plotH;

    const svg = elNS('svg');
    svg.setAttribute('width', '100%');
    svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
    svg.style.display = 'block';
    svg.style.margin = '10px 0 14px';

    // Background
    svg.appendChild(rect(0,0,W,H,'rgba(255,255,255,0.015)'));

    // Title
    svg.appendChild(textEl(metric.title, margin.left, 18, {
      size: 15,
      weight: 900,
      fill: '#e5e7eb'
    }));

    // Y-axis label
    svg.appendChild(textEl(metric.unit, 14, margin.top + plotH/2, {
      size: 12,
      weight: 800,
      fill: '#94a3b8',
      rotate: -90,
      rotateOrigin: `14 ${margin.top + plotH/2}`
    }));

    // Bands (contiguous; avoids white stripes)
    for (const r of metric.ranges){
      const start = r.start;
      const end = (r.end === Infinity ? yTop : Math.min(r.end, yTop));
      if (start >= yTop) continue;

      const y1 = y(end);
      const y2 = y(start);
      svg.appendChild(rect(margin.left, y1, plotW, (y2 - y1), r.color, 0.60));

      // Right-side label
      const yMid = y1 + (y2 - y1)/2;
      const lbl = textEl(r.label, margin.left + plotW + 10, yMid + 4, {
        size: 11,
        weight: 800,
        fill: '#d1d5db'
      });
      svg.appendChild(lbl);
    }

    // Grid + y ticks
    const gridCount = 5;
    for (let i=0; i<=gridCount; i++){
      const v = (yTop / gridCount) * i;
      const yy = y(v);
      svg.appendChild(line(margin.left, yy, margin.left + plotW, yy, 'rgba(255,255,255,0.10)', 1, '4,4'));
      svg.appendChild(textEl(formatTick(v, metric.key), margin.left - 8, yy + 4, {
        size: 11,
        weight: 700,
        fill: '#cbd5e1',
        anchor: 'end'
      }));
    }

    // X axis baseline
    svg.appendChild(line(margin.left, margin.top + plotH, margin.left + plotW, margin.top + plotH, 'rgba(255,255,255,0.20)', 1.2));

    // X ticks (auto)
    const ticks = makeTimeTicks(xMin, xMax, 5);
    for (const t of ticks){
      const xx = margin.left + ((t - xMin) / (xMax - xMin)) * plotW;
      svg.appendChild(line(xx, margin.top + plotH, xx, margin.top + plotH + 6, 'rgba(255,255,255,0.20)', 1));
      svg.appendChild(textEl(formatDateTick(new Date(t), xMin, xMax), xx, margin.top + plotH + 22, {
        size: 11,
        weight: 700,
        fill: '#cbd5e1',
        anchor: 'middle'
      }));
    }

    // Build series points
    const pts = rows
      .filter(r => r[metric.key] != null)
      .map(r => ({ d: r.Date, v: r[metric.key] }));

    // Line
    if (pts.length >= 1){
      const path = pts.map((p, i) => `${i===0 ? 'M' : 'L'} ${x(p.d).toFixed(2)} ${y(p.v).toFixed(2)}`).join(' ');
      const pEl = elNS('path');
      pEl.setAttribute('d', path);
      pEl.setAttribute('fill', 'none');
      pEl.setAttribute('stroke', '#0b0f14');
      pEl.setAttribute('stroke-width', '4');
      pEl.setAttribute('opacity', '0.55');
      svg.appendChild(pEl);

      const pEl2 = elNS('path');
      pEl2.setAttribute('d', path);
      pEl2.setAttribute('fill', 'none');
      pEl2.setAttribute('stroke', '#000');
      pEl2.setAttribute('stroke-width', '2.5');
      svg.appendChild(pEl2);

      // Points + labels
      for (const p of pts){
        const cx = x(p.d);
        const cy = y(p.v);
        svg.appendChild(circle(cx, cy, 4.5, '#000'));

        // value label with white pill background
        const label = formatValue(p.v, metric.key);
        const padX = 6;
        const padY = 4;
        const textSize = 12;

        // approximate text width (good enough)
        const approxW = Math.max(20, label.length * 7.1);
        const boxW = approxW + padX*2;
        const boxH = textSize + padY*2;

        const bx = cx - boxW/2;
        const by = cy - 22 - boxH/2;

        svg.appendChild(roundRect(bx, by, boxW, boxH, 6, 'rgba(255,255,255,0.92)'));
        svg.appendChild(textEl(label, cx, by + boxH/2 + 4, {
          size: 12,
          weight: 900,
          fill: '#0b0f14',
          anchor: 'middle'
        }));
      }
    }

    return svg;
  }

  function makeTimeTicks(minT, maxT, count){
    const ticks = [];
    const span = maxT - minT;
    if (span <= 0) return [minT, maxT];

    // choose tick spacing roughly based on span
    const day = 86400000;
    const month = 30*day;
    const year = 365*day;

    let step;
    if (span <= 120*day) step = 30*day;           // ~monthly
    else if (span <= 540*day) step = 90*day;      // ~quarterly
    else if (span <= 2.5*year) step = 180*day;    // ~semiannual
    else step = 365*day;

    // start at nearest step boundary
    let t = minT;
    // just evenly distribute if very short
    const target = Math.min(6, Math.max(3, count));
    const approx = Math.floor(span / step) + 1;

    if (approx < target){
      // evenly spaced
      for (let i=0; i<target; i++){
        ticks.push(minT + (span * i)/(target-1));
      }
      return ticks;
    }

    // walk forward in steps
    while (t <= maxT + 1){
      ticks.push(t);
      t += step;
      if (ticks.length > 8) break;
    }

    // ensure last tick near end
    if (ticks[ticks.length-1] < maxT - step*0.35) ticks.push(maxT);

    // de-dup close ticks
    return ticks.filter((v,i,a)=> i===0 || Math.abs(v-a[i-1]) > step*0.35);
  }

  function formatDateTick(d, minT, maxT){
    const span = maxT - minT;
    const day = 86400000;
    const showYear = span > 320*day;
    const fmt = new Intl.DateTimeFormat(undefined, showYear
      ? { month:'short', year:'numeric' }
      : { month:'short', day:'numeric' }
    );
    return fmt.format(d);
  }

  function formatValue(v, key){
    if (key === 'HBA1C') return v.toFixed(1);
    // avoid trailing .0 for integers
    return Number.isInteger(v) ? String(v) : String(v);
  }

  function formatTick(v, key){
    if (key === 'HBA1C') return v.toFixed(1);
    // show clean integers
    const rounded = Math.round(v);
    return String(rounded);
  }

  // -------------------------
  // SVG helper functions
  // -------------------------
  function elNS(tag){
    return document.createElementNS('http://www.w3.org/2000/svg', tag);
  }

  function rect(x,y,w,h,fill,opacity){
    const r = elNS('rect');
    r.setAttribute('x', x);
    r.setAttribute('y', y);
    r.setAttribute('width', w);
    r.setAttribute('height', h);
    r.setAttribute('fill', fill);
    if (opacity != null) r.setAttribute('opacity', String(opacity));
    return r;
  }

  function roundRect(x,y,w,h,rad,fill,opacity){
    const r = rect(x,y,w,h,fill,opacity);
    r.setAttribute('rx', rad);
    r.setAttribute('ry', rad);
    return r;
  }

  function line(x1,y1,x2,y2,stroke,width,dash){
    const l = elNS('line');
    l.setAttribute('x1', x1);
    l.setAttribute('y1', y1);
    l.setAttribute('x2', x2);
    l.setAttribute('y2', y2);
    l.setAttribute('stroke', stroke);
    l.setAttribute('stroke-width', width);
    if (dash) l.setAttribute('stroke-dasharray', dash);
    return l;
  }

  function circle(cx,cy,r,fill){
    const c = elNS('circle');
    c.setAttribute('cx', cx);
    c.setAttribute('cy', cy);
    c.setAttribute('r', r);
    c.setAttribute('fill', fill);
    return c;
  }

  function textEl(str, x, y, opts={}){
    const t = elNS('text');
    t.textContent = str;
    t.setAttribute('x', x);
    t.setAttribute('y', y);
    t.setAttribute('fill', opts.fill ?? '#e5e7eb');
    t.setAttribute('font-size', opts.size ?? 12);
    t.setAttribute('font-weight', opts.weight ?? 700);
    if (opts.anchor) t.setAttribute('text-anchor', opts.anchor);
    if (opts.rotate != null){
      t.setAttribute('transform', `rotate(${opts.rotate} ${opts.rotateOrigin ?? (x+' '+y)})`);
    }
    return t;
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  function getCss(name){
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  }
</script>
</body>
</html>
